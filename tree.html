<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>-</title>
  <style>
    html {
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 12px;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    @media print {
      html {
        background-color: white;
      }
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, Consolas, 'Lucida Console', monospace;
      font-size: 85%;
      margin: 0;
      hyphens: manual;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      background-color: #1a1a1a;
      border: none;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
    /* CSS for syntax highlighting */
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { color: #008000; } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { color: #008000; font-weight: bold; } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<p><a id="dharma.tree"></a></p>
<h1 id="dharma.tree">dharma.tree</h1>
<p>XML tree representation</p>
<p>Node types are: <code>Tree</code>, <code>Tag</code>,
<code>Comment</code>, <code>String</code>, <code>Instruction</code>.
Attributes are not represented as nodes, because I don’t really see the
point. All node types derive from an abstract base class
<code>Node</code>. There is no inheritance relationship between the
different kinds of nodes: <code>Comment</code> is not a subclass of
<code>String</code> (unlike in bs4). Thus, to check whether a node is of
a given type, using <code>isinstance(node, Comment)</code>, etc. is
sufficient.</p>
<p><code>Tree</code> is the XML document proper, which contains a single
tag node and optionally comments and processing instructions. The XML
tradition is to treat the document itself as the root of the tree, while
in the DOM the document’s root is not the document itself but its unique
element node, viz. <code>&lt;html&gt;</code> in HTML documents.</p>
<p>We follow the second model, mostly out of habit. This means that the
tree root e.g. <code>&lt;TEI&gt;</code> and other nodes at this level
have no parent (<code>node.parent</code> is None for them). Still, the
<code>Tree</code> node is considered to have children, which is
admittedly weird. Nodes that have been detached from the tree with
<code>node.unwrap()</code>, etc. also have no parent (nor tree). If we
did not use the DOM, we would have to attach them all to new trees to
keep the behavior consistent.</p>
<p>When parsing documents, we always normalize spaces in attributes: we
replace all sequences of whitespace characters with ” ” and we trim
whitespace from both sides.</p>
<p>For simplicity, we do not deal with XML namespaces at all. We just
remove namespace prefixes in both elements and attributes. Thus,
<code>&lt;xsl:template&gt;</code> becomes <code>&lt;template&gt;</code>,
and <code>&lt;foo xml:lang="eng"&gt;</code> becomes
<code>&lt;foo lang="eng"&gt;</code>. This means that we cannot deal with
documents where namespaces are significant.</p>
<p><a id="dharma.tree.Location"></a></p>
<h4 id="location">Location</h4>
<p>Represents the location of a node in an XML file.</p>
<p><a id="dharma.tree.Error"></a></p>
<h2 id="error-objects">Error Objects</h2>
<div class="sourceCode" id="cb1"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Error(<span class="pp">Exception</span>)</span></code></pre></div>
<p>Raised for parsing errors.</p>
<p><a id="dharma.tree.Node"></a></p>
<h2 id="node-objects">Node Objects</h2>
<div class="sourceCode" id="cb2"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Node(<span class="bu">object</span>)</span></code></pre></div>
<p><a id="dharma.tree.Node.tree"></a></p>
<h4 id="tree">tree</h4>
<p><code>Tree</code> this node belongs to. This can be
<code>None</code>, because nodes do not necessarily belong to a
<code>Tree</code>. The only node type that necessarily belongs to a
<code>Tree</code> is <code>Tree</code>.</p>
<p><a id="dharma.tree.Node.location"></a></p>
<h4 id="location-1">location</h4>
<p><code>Location</code> object, which indicates the boundaries of the
node in the XML source it was constructed from, if any.</p>
<p><a id="dharma.tree.Node.parent"></a></p>
<h4 id="parent">parent</h4>
<p>Is always <code>None</code> for <code>Tree</code> nodes, for children
of <code>Tree</code> nodes, and for root <code>Tag</code> nodes that are
not attached to a <code>Tree</code>.</p>
<p><a id="dharma.tree.Node.type"></a></p>
<h4 id="type">type</h4>
<p>A string, one of “tree”, “tag”, “string”, “comment”,
“instruction”.</p>
<p><a id="dharma.tree.Node.source"></a></p>
<h4 id="source">source</h4>
<div class="sourceCode" id="cb3"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="at">@property</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> source()</span></code></pre></div>
<p>XML source of this subtree, as it appears in the file it was parsed
from.</p>
<p>If the subtree has been constructed programmatically, or if it was
modified, extracted from its tree, etc., this is set to None.</p>
<p><a id="dharma.tree.Node.delete"></a></p>
<h4 id="delete">delete</h4>
<div class="sourceCode" id="cb4"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> delete()</span></code></pre></div>
<p>Removes this node and all its descendants from the tree. Returns the
removed subtree.</p>
<p><a id="dharma.tree.Node.replace_with"></a></p>
<h4 id="replace_with">replace_with</h4>
<div class="sourceCode" id="cb5"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> replace_with(other)</span></code></pre></div>
<p>Removes this node and its descendants from the tree, and puts another
node in its place. Returns the removed subtree.</p>
<p><a id="dharma.tree.Node.text"></a></p>
<h4 id="text">text</h4>
<div class="sourceCode" id="cb6"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> text(space<span class="op">=</span><span class="st">&quot;default&quot;</span>)</span></code></pre></div>
<p>Returns the text contents of this subtree. Per default, we do
normalize-space(); to prevent this, pass
<code>space="preserve"</code>.</p>
<p><a id="dharma.tree.Node.xml"></a></p>
<h4 id="xml">xml</h4>
<div class="sourceCode" id="cb7"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> xml(<span class="op">**</span>kwargs)</span></code></pre></div>
<p>Returns an XML representation of this subtree, typically not
identical to the original XML source, if any.</p>
<p><a id="dharma.tree.Node.copy"></a></p>
<h4 id="copy">copy</h4>
<div class="sourceCode" id="cb8"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> copy()</span></code></pre></div>
<p>Makes a copy of this subtree. The returned object holds no reference
to the original.</p>
<p>If the copied node is the tree itself, the file path of the copied
tree is set to None, whether or not the original did have a file path.
Children nodes of the new tree will reference this new tree.</p>
<p>If the copied node is a child node of a tree object, then it will not
have a parent node, and both itself and its children node will have an
empty tree attribute.</p>
<p><a id="dharma.tree.Node.unwrap"></a></p>
<h4 id="unwrap">unwrap</h4>
<div class="sourceCode" id="cb9"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> unwrap()</span></code></pre></div>
<p>Removes a node from the tree but leaves its descendants in-place.
Cannot be called on a <code>Tree</code> node or on a root
<code>Tag</code> node. Calling this on other types of nodes just deletes
them.</p>
<p><a id="dharma.tree.Node.coalesce"></a></p>
<h4 id="coalesce">coalesce</h4>
<div class="sourceCode" id="cb10"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> coalesce()</span></code></pre></div>
<p>Coalesce adjacent string nodes and removes empty string nodes from
this subtree. Has no effect on nodes other than <code>Tree</code> and
<code>Tag</code>.</p>
<p><a id="dharma.tree.Branch"></a></p>
<h2 id="branch-objects">Branch Objects</h2>
<div class="sourceCode" id="cb11"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Branch(Node, <span class="bu">list</span>)</span></code></pre></div>
<p><a id="dharma.tree.Branch.locate"></a></p>
<h4 id="locate">locate</h4>
<div class="sourceCode" id="cb12"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> locate(path)</span></code></pre></div>
<p>Find the node that matches the given xpath expression. This only
works for basic expressions of the form: <code>/</code>,
<code>/foo[1]</code>, <code>/foo[1]/bar[5]</code>, etc. The path of a
Node is given in its path attribute.</p>
<p><a id="dharma.tree.Branch.path"></a></p>
<h4 id="path">path</h4>
<div class="sourceCode" id="cb13"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="at">@property</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> path()</span></code></pre></div>
<p>The path of this node</p>
<p><a id="dharma.tree.Tag"></a></p>
<h2 id="tag-objects">Tag Objects</h2>
<div class="sourceCode" id="cb14"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Tag(Branch)</span></code></pre></div>
<p><a id="dharma.tree.Tag.__init__"></a></p>
<h4 id="init__">__init__</h4>
<div class="sourceCode" id="cb15"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> <span class="fu">__init__</span>(name, <span class="op">*</span>attributes_iter, <span class="op">**</span>attributes)</span></code></pre></div>
<p>The argument <code>name</code> is the name of the node as a string,
e.g. “html”. The positional argument <code>*attributes_iter</code> is
optional. If given, it must be a single iterator that returns tuples of
the form <code>(key, value)</code>, or a <code>dict</code> subclass.
Attributes can also be passed as keyword arguments with
<code>**attributes</code>.</p>
<p>Attributes ordering is preserved for attributes passed through
<code>*attributes_iter</code>. This is the reason we have it. New
attributes created manually with e.g. <code>node["attr"] = "foo"</code>
are added at the end of the attributes list (we use an OrderedDict under
the hood).</p>
<p><a id="dharma.tree.Tree"></a></p>
<h2 id="tree-objects">Tree Objects</h2>
<div class="sourceCode" id="cb16"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Tree(Branch)</span></code></pre></div>
<p><a id="dharma.tree.Tree.file"></a></p>
<h4 id="file">file</h4>
<p>Path of the XML file this tree was constructed from.</p>
<p><a id="dharma.tree.Tree.root"></a></p>
<h4 id="root">root</h4>
<p>The tree root tag. Might be None temporarily, if the Tree node is
created programmatically, but in any case it should have a root to
become a valid XML document.</p>
<p><a id="dharma.tree.Tree.source"></a></p>
<h4 id="source-1">source</h4>
<p>XML source, in bytes, encoded as UTF-8.</p>
</body>
</html>
