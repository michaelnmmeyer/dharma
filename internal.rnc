# Schema for the internal representation.
#
# There are two basic categories of elements: inline elements (spans of text)
# and block elements (divisions, paragraphs, etc.).
#
# * Main divisions: summary, hand, edition, apparatus, translation, commentary,
# bibliography.
#
# * Other division: div.
#
# * Paragraph-like: para, verse (which should only contain verse-line), head.
#
# * Containers: elist (which should only contain item), dlist (which should only
#   contain series of (key, value))
#
# * Division-like: note, quote, item, key, value. They should only contain para,
#   verse, elist, dlist, quote.
#
# * Inline elements: span, link, milestones (npage, nline, ncell), display, split.
#
# Before patching, can also have <views> which holds exactly three child nodes
# <physical>, <logical>, <full>. This element is expanded differently depending on
# the edition display.

Also a <source> element.

default namespace = ""

block = para | verse | quote | dlist | elist

# Elements that do not cross a paragraph boundary or a line boundary.
inline = text | span | link | note | milestone | display | split

milestone = npage | nline | ncell

# This stores two things: display holds what we should display, search is a
# textual representation of the same that will be used for searching.
split = element split {
	display,
	element search { text }
}

start = element document {
	# Three data fields: title, author, editor. They should not contain
	# paragraphs. If there are several titles, the first one is the one that
	# should be displayed.
	element title { inline+ }*,
	element author { name, identifier? }*,
	element editor { name, identifier? }*,
	element summary { block+ }?,
	element hand { block+ }?,
	element edition-languages {
		element language { name, identifier }+
	},
	edition?,
	apparatus?,
	translation*,
	commentary?,
	bibliography?
}
edition = element edition {
	head,
	element physical { (physical_div | page)+ }, # XXX should have (block+ | ediv+): cover everything with div if needed (as for milestones), with "phantom" divisions. if we do this, a div should not have a mandatory <head>. same applies to the other divs below: apparatus, etc.
	element logical { (ediv | block)* },
	element full { (ediv | block)* }
}
apparatus = element apparatus {
	head,
	(ediv | block)*
}
translation = element translation {
	head,
	(ediv | block)*
}
commentary = element commentary {
	head,
	(ediv | block)*
}
bibliography = element bibliography {
	head,
	(ediv | block)*
}

note = element note {
	# Notes numbers must be unique, except within the edition division.
	# Because in the latter, we generate three representations: physical,
	# logical, full; there are thus 3 copies of each note.
	attribute n { xsd:integer },
	block*
}
span = element span {
	attribute class { text }?,
	# standalone is for spans corresponding to one of sic corr orig reg; if
	# standalone=false, the element is paired with another (sic/corr
	# orig/reg), otherwise the element appears on its own, it is not on its
	# own. XXX should get rid of standalone. we should just have sic corr
	# orig reg elements in the internal format, and then the patch utility
	# would pair back stuff. but then we can't distinguish between a sic
	# followed by a corr and a pair sic/corr, so this should be annotated
	# early.
	attribute standalone { xsd:boolean }?,
	attribute tip { text }?,
	inline*
}
name = element name { text }
identifier = element identifier { text }
para = element para {
	attribute anchor { text }?,
	attribute class { text }?,
	inline*
}
elist = element elist {
	attribute type { "plain" | "bulleted" | "numbered" },
	element item { block* }*
}
dlist = element dlist {
	(element key { block* }, element value { block* })*
}
quote = element quote {
	element source { inline+ }?,
	block*
}
head = element head { inline+ }
ediv = element div {
	head?,
	(ediv* | block*)
}
physical_div = element div {
	head?,
	(physical_div* | page*)
}
page = element page {
	head?,
	element line { inline* }*
}
verse = element verse {
	element verse-head { inline+ }?,
	verse-line+,
}
verse-line = element verse-line {
	attribute break { xsd:boolean }?,
	attribute n { text }?,
	attribute tip { text }?,
	(text | link | elist | ncell | nline | note | npage | span)*
}

link = element link {
	# @href is absent if the link is invalid.
	attribute href { xsd:anyURI }?,
	inline+
}

display = element display { inline+ }

# Milestones. The contents is something to display. If the milestone has
# @phantom=true, there is no contents to display.
npage = element npage {
	attribute break { xsd:boolean },
	attribute phantom { xsd:boolean },
	inline*
}
nline = element nline {
	attribute break { xsd:boolean },
	attribute phantom { xsd:boolean },
	inline*
}
ncell = element ncell {
	attribute break { xsd:boolean },
	attribute phantom { xsd:boolean },
	inline*
}
