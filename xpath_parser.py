#!/usr/bin/env python3.8
# @generated by pegen from xpath_parser.g

import ast
import sys
import tokenize

from typing import Any, Optional

from pegen.parser import memoize, memoize_left_rec, logger, Parser

def assign(obj, **kwargs):
	for k, v in kwargs.items():
		assert hasattr(obj, k), "%r has no attr %r" % (obj, k)
		setattr(obj, k, v)
	return obj

class Path:

	def __init__(self):
		self.steps = []
		self.absolute = False

	def append(self, step):
		self.steps.append(step)
		return self

	def prepend(self, step):
		self.steps.insert(0, step)
		return self

	def __repr__(self):
		return "Path(absolute=%r, steps=%r)" % (self.absolute, self.steps)

class Step:

	def __init__(self):
		self.axis = "child"
		self.name_test = None
		self.predicates = []
		self.abbreviated = False

	def __repr__(self):
		return "Step(axis=%r, name_test=%r, predicates=%r)" % (self.axis, self.name_test, self.predicates)

class Op:

	# l is None if this is a unary operator.
	def __init__(self, val, l, r):
		self.val = val
		self.l = l
		self.r = r

	def __repr__(self):
		return "Op(%r, %r, %r)" % (self.val, self.l, self.r)

class Func:

	def __init__(self, name, args):
		self.name = name
		self.args = args

	def __repr__(self):
		return "Func(%r, %r)" % (self.name, self.args)

# Keywords and soft keywords are listed at the end of the parser definition.
class GeneratedParser(Parser):

    @memoize
    def start(self) -> Optional[Any]:
        # start: LocationPath $
        mark = self._mark()
        if (
            (r := self.LocationPath())
            and
            (self.expect('ENDMARKER'))
        ):
            return r;
        self._reset(mark)
        return None;

    @memoize
    def LocationPath(self) -> Optional[Any]:
        # LocationPath: RelativeLocationPath | AbsoluteLocationPath
        mark = self._mark()
        if (
            (RelativeLocationPath := self.RelativeLocationPath())
        ):
            return RelativeLocationPath;
        self._reset(mark)
        if (
            (r := self.AbsoluteLocationPath())
        ):
            return assign ( r , absolute = True );
        self._reset(mark)
        return None;

    @memoize
    def AbsoluteLocationPath(self) -> Optional[Any]:
        # AbsoluteLocationPath: AbbreviatedAbsoluteLocationPath | '/' RelativeLocationPath?
        mark = self._mark()
        if (
            (AbbreviatedAbsoluteLocationPath := self.AbbreviatedAbsoluteLocationPath())
        ):
            return AbbreviatedAbsoluteLocationPath;
        self._reset(mark)
        if (
            (self.expect('/'))
            and
            (r := self.RelativeLocationPath(),)
        ):
            return r or Path ( );
        self._reset(mark)
        return None;

    @memoize_left_rec
    def RelativeLocationPath(self) -> Optional[Any]:
        # RelativeLocationPath: AbbreviatedRelativeLocationPath | RelativeLocationPath '/' Step | Step
        mark = self._mark()
        if (
            (AbbreviatedRelativeLocationPath := self.AbbreviatedRelativeLocationPath())
        ):
            return AbbreviatedRelativeLocationPath;
        self._reset(mark)
        if (
            (r := self.RelativeLocationPath())
            and
            (self.expect('/'))
            and
            (s := self.Step())
        ):
            return r . append ( s );
        self._reset(mark)
        if (
            (r := self.Step())
        ):
            return Path ( ) . append ( r );
        self._reset(mark)
        return None;

    @memoize
    def AbbreviatedAbsoluteLocationPath(self) -> Optional[Any]:
        # AbbreviatedAbsoluteLocationPath: '//' RelativeLocationPath
        mark = self._mark()
        if (
            (self.expect('//'))
            and
            (r := self.RelativeLocationPath())
        ):
            return r . prepend ( assign ( Step ( ) , axis = "descendant-or-self" , abbreviated = True ) );
        self._reset(mark)
        return None;

    @logger
    def AbbreviatedRelativeLocationPath(self) -> Optional[Any]:
        # AbbreviatedRelativeLocationPath: RelativeLocationPath '//' Step
        mark = self._mark()
        if (
            (r := self.RelativeLocationPath())
            and
            (self.expect('//'))
            and
            (s := self.Step())
        ):
            return r . append ( assign ( Step ( ) , axis = "descendant-or-self" , abbreviated = True ) ) . append ( s );
        self._reset(mark)
        return None;

    @memoize
    def AbbreviatedStep(self) -> Optional[Any]:
        # AbbreviatedStep: '.' '.' | '.'
        mark = self._mark()
        if (
            (self.expect('.'))
            and
            (self.expect('.'))
        ):
            return assign ( Step ( ) , axis = "parent" , abbreviated = True );
        self._reset(mark)
        if (
            (self.expect('.'))
        ):
            return assign ( Step ( ) , axis = "self" , abbreviated = True );
        self._reset(mark)
        return None;

    @memoize
    def Step(self) -> Optional[Any]:
        # Step: AxisSpecifier? NodeTest Predicate* | AbbreviatedStep
        mark = self._mark()
        if (
            (q := self.AxisSpecifier(),)
            and
            (r := self.NodeTest())
            and
            (s := self._loop0_1(),)
        ):
            return assign ( r , axis = q or "child" , predicates = s );
        self._reset(mark)
        if (
            (r := self.AbbreviatedStep())
        ):
            return r;
        self._reset(mark)
        return None;

    @memoize
    def AxisSpecifier(self) -> Optional[Any]:
        # AxisSpecifier: AxisName ':' ':'
        mark = self._mark()
        if (
            (r := self.AxisName())
            and
            (self.expect(':'))
            and
            (self.expect(':'))
        ):
            return r . string;
        self._reset(mark)
        return None;

    @memoize
    def AxisName(self) -> Optional[Any]:
        # AxisName: "ancestor-or-self" | "ancestor" | "child" | "descendant-or-self" | "descendant" | "following-sibling" | "parent" | "preceding-sibling" | "self"
        mark = self._mark()
        if (
            (literal := self.expect("ancestor-or-self"))
        ):
            return literal;
        self._reset(mark)
        if (
            (literal := self.expect("ancestor"))
        ):
            return literal;
        self._reset(mark)
        if (
            (literal := self.expect("child"))
        ):
            return literal;
        self._reset(mark)
        if (
            (literal := self.expect("descendant-or-self"))
        ):
            return literal;
        self._reset(mark)
        if (
            (literal := self.expect("descendant"))
        ):
            return literal;
        self._reset(mark)
        if (
            (literal := self.expect("following-sibling"))
        ):
            return literal;
        self._reset(mark)
        if (
            (literal := self.expect("parent"))
        ):
            return literal;
        self._reset(mark)
        if (
            (literal := self.expect("preceding-sibling"))
        ):
            return literal;
        self._reset(mark)
        if (
            (literal := self.expect("self"))
        ):
            return literal;
        self._reset(mark)
        return None;

    @memoize
    def NodeTest(self) -> Optional[Any]:
        # NodeTest: NameTest
        mark = self._mark()
        if (
            (NameTest := self.NameTest())
        ):
            return NameTest;
        self._reset(mark)
        return None;

    @memoize
    def NameTest(self) -> Optional[Any]:
        # NameTest: '*' | NAME
        mark = self._mark()
        if (
            (self.expect('*'))
        ):
            return Step ( );
        self._reset(mark)
        if (
            (r := self.name())
        ):
            return assign ( Step ( ) , name_test = r . string );
        self._reset(mark)
        return None;

    @memoize
    def Predicate(self) -> Optional[Any]:
        # Predicate: '[' PredicateExpr ']'
        mark = self._mark()
        if (
            (self.expect('['))
            and
            (r := self.PredicateExpr())
            and
            (self.expect(']'))
        ):
            return r;
        self._reset(mark)
        return None;

    @memoize
    def PredicateExpr(self) -> Optional[Any]:
        # PredicateExpr: Expr
        mark = self._mark()
        if (
            (Expr := self.Expr())
        ):
            return Expr;
        self._reset(mark)
        return None;

    @memoize
    def Expr(self) -> Optional[Any]:
        # Expr: OrExpr
        mark = self._mark()
        if (
            (OrExpr := self.OrExpr())
        ):
            return OrExpr;
        self._reset(mark)
        return None;

    @memoize
    def PrimaryExpr(self) -> Optional[Any]:
        # PrimaryExpr: '(' Expr ')' | Literal | FunctionCall | '@' NAME
        mark = self._mark()
        if (
            (self.expect('('))
            and
            (r := self.Expr())
            and
            (self.expect(')'))
        ):
            return r;
        self._reset(mark)
        if (
            (Literal := self.Literal())
        ):
            return Literal;
        self._reset(mark)
        if (
            (FunctionCall := self.FunctionCall())
        ):
            return FunctionCall;
        self._reset(mark)
        if (
            (self.expect('@'))
            and
            (r := self.name())
        ):
            return f"(node[{r.string!r}])";
        self._reset(mark)
        return None;

    @memoize_left_rec
    def OrExpr(self) -> Optional[Any]:
        # OrExpr: OrExpr "or" AndExpr | AndExpr
        mark = self._mark()
        if (
            (r := self.OrExpr())
            and
            (self.expect("or"))
            and
            (s := self.AndExpr())
        ):
            return Op ( "or" , r , s );
        self._reset(mark)
        if (
            (AndExpr := self.AndExpr())
        ):
            return AndExpr;
        self._reset(mark)
        return None;

    @memoize_left_rec
    def AndExpr(self) -> Optional[Any]:
        # AndExpr: AndExpr "and" NotExpr | NotExpr
        mark = self._mark()
        if (
            (r := self.AndExpr())
            and
            (self.expect("and"))
            and
            (s := self.NotExpr())
        ):
            return Op ( "and" , r , s );
        self._reset(mark)
        if (
            (NotExpr := self.NotExpr())
        ):
            return NotExpr;
        self._reset(mark)
        return None;

    @memoize
    def NotExpr(self) -> Optional[Any]:
        # NotExpr: "not" NotExpr | EqualityExpr
        mark = self._mark()
        if (
            (self.expect("not"))
            and
            (r := self.NotExpr())
        ):
            return Op ( "not" , None , r );
        self._reset(mark)
        if (
            (EqualityExpr := self.EqualityExpr())
        ):
            return EqualityExpr;
        self._reset(mark)
        return None;

    @memoize_left_rec
    def EqualityExpr(self) -> Optional[Any]:
        # EqualityExpr: EqualityExpr '=' RelationalExpr | EqualityExpr '!=' RelationalExpr | RelationalExpr
        mark = self._mark()
        if (
            (r := self.EqualityExpr())
            and
            (self.expect('='))
            and
            (s := self.RelationalExpr())
        ):
            return Op ( "==" , r , s );
        self._reset(mark)
        if (
            (r := self.EqualityExpr())
            and
            (self.expect('!='))
            and
            (s := self.RelationalExpr())
        ):
            return Op ( "!=" , r , s );
        self._reset(mark)
        if (
            (RelationalExpr := self.RelationalExpr())
        ):
            return RelationalExpr;
        self._reset(mark)
        return None;

    @memoize_left_rec
    def RelationalExpr(self) -> Optional[Any]:
        # RelationalExpr: RelationalExpr '<' AdditiveExpr | RelationalExpr '>' AdditiveExpr | RelationalExpr '<=' AdditiveExpr | RelationalExpr '>=' AdditiveExpr | AdditiveExpr
        mark = self._mark()
        if (
            (r := self.RelationalExpr())
            and
            (self.expect('<'))
            and
            (s := self.AdditiveExpr())
        ):
            return Op ( "<" , r , s );
        self._reset(mark)
        if (
            (r := self.RelationalExpr())
            and
            (self.expect('>'))
            and
            (s := self.AdditiveExpr())
        ):
            return Op ( ">" , r , s );
        self._reset(mark)
        if (
            (r := self.RelationalExpr())
            and
            (self.expect('<='))
            and
            (s := self.AdditiveExpr())
        ):
            return Op ( "<=" , r , s );
        self._reset(mark)
        if (
            (r := self.RelationalExpr())
            and
            (self.expect('>='))
            and
            (s := self.AdditiveExpr())
        ):
            return Op ( ">=" , r , s );
        self._reset(mark)
        if (
            (AdditiveExpr := self.AdditiveExpr())
        ):
            return AdditiveExpr;
        self._reset(mark)
        return None;

    @memoize
    def AdditiveExpr(self) -> Optional[Any]:
        # AdditiveExpr: UnionExpr
        mark = self._mark()
        if (
            (UnionExpr := self.UnionExpr())
        ):
            return UnionExpr;
        self._reset(mark)
        return None;

    @memoize
    def UnionExpr(self) -> Optional[Any]:
        # UnionExpr: PathExpr
        mark = self._mark()
        if (
            (PathExpr := self.PathExpr())
        ):
            return PathExpr;
        self._reset(mark)
        return None;

    @memoize
    def PathExpr(self) -> Optional[Any]:
        # PathExpr: FilterExpr | LocationPath
        mark = self._mark()
        if (
            (FilterExpr := self.FilterExpr())
        ):
            return FilterExpr;
        self._reset(mark)
        if (
            (LocationPath := self.LocationPath())
        ):
            return LocationPath;
        self._reset(mark)
        return None;

    @memoize
    def FilterExpr(self) -> Optional[Any]:
        # FilterExpr: PrimaryExpr
        mark = self._mark()
        if (
            (PrimaryExpr := self.PrimaryExpr())
        ):
            return PrimaryExpr;
        self._reset(mark)
        return None;

    @memoize
    def FunctionCall(self) -> Optional[Any]:
        # FunctionCall: FunctionName '(' Arguments? ')'
        mark = self._mark()
        if (
            (r := self.FunctionName())
            and
            (self.expect('('))
            and
            (s := self.Arguments(),)
            and
            (self.expect(')'))
        ):
            return Func ( r , s or [] );
        self._reset(mark)
        return None;

    @memoize
    def FunctionName(self) -> Optional[Any]:
        # FunctionName: NAME
        mark = self._mark()
        if (
            (r := self.name())
        ):
            return r . string;
        self._reset(mark)
        return None;

    @memoize
    def Arguments(self) -> Optional[Any]:
        # Arguments: ','.Argument+
        mark = self._mark()
        if (
            (r := self._gather_2())
        ):
            return r;
        self._reset(mark)
        return None;

    @memoize
    def Argument(self) -> Optional[Any]:
        # Argument: Expr
        mark = self._mark()
        if (
            (Expr := self.Expr())
        ):
            return Expr;
        self._reset(mark)
        return None;

    @memoize
    def Literal(self) -> Optional[Any]:
        # Literal: STRING
        mark = self._mark()
        if (
            (r := self.string())
        ):
            return r . string;
        self._reset(mark)
        return None;

    @memoize
    def _loop0_1(self) -> Optional[Any]:
        # _loop0_1: Predicate
        mark = self._mark()
        children = []
        while (
            (Predicate := self.Predicate())
        ):
            children.append(Predicate)
            mark = self._mark()
        self._reset(mark)
        return children;

    @memoize
    def _loop0_3(self) -> Optional[Any]:
        # _loop0_3: ',' Argument
        mark = self._mark()
        children = []
        while (
            (self.expect(','))
            and
            (elem := self.Argument())
        ):
            children.append(elem)
            mark = self._mark()
        self._reset(mark)
        return children;

    @memoize
    def _gather_2(self) -> Optional[Any]:
        # _gather_2: Argument _loop0_3
        mark = self._mark()
        if (
            (elem := self.Argument())
            is not None
            and
            (seq := self._loop0_3())
            is not None
        ):
            return [elem] + seq;
        self._reset(mark)
        return None;

    KEYWORDS = ()
    SOFT_KEYWORDS = ('ancestor', 'and', 'child', 'descendant', 'not', 'or', 'parent', 'self')


if __name__ == '__main__':
    from pegen.parser import simple_parser_main
    simple_parser_main(GeneratedParser)
