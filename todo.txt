stop using tables, annoying to style. use ul instead.

add line numbers to xml display

transactions migt be stopped when we turn down the vm. so must try to catch up
at start up. and also do that regularly in case we have a q overflow. just try
to do a full update.

---

must merge all dbs together, except for the github log (rename
"github.sqlite"). use the db name as a prefix in table names, so we can still
do select on multi tables.

move texts db stuff in change.py to texts.py

store raw xml in files db (needed for transactions to work). doing that also
ensures we can just move the main db and use it read-only without having repos
somewhere. store both texts and other xml files we need (prosody, members). all
of this in a single table, where the key is the filename (file names should be
unique). schemas should be hard copied into my repo after each change. must
also deal with dependencies, but just list the "global" files we need, it's
simpler.

create table files(
   name text primary key not null,
   repo text not null,
   path text not null,
   mtime integer not null,
   data blob not null
);

Find a way to merge several tooltips when necessary as in A | B ... for this to
work, must annotate spans of text. And use a data table for common cases where
no dynamic generation is necessary (or at least to provide a general
explanation). Should also attach to each generated piece of text the xml node
it comes from (with lineno), to make it easier to debug stuff. Should also
highlight stuff that has a tooltip on mouseover. or add sth that indicates that
it has a tooltip.

Can add options to the xml display. Just a "pretty" option where we might or
not include comments. Need to have a pretty-print func that preserves space and
doesn't add unnecessary space.

---

For Manu and github issues see if errors always happen with editorial stuff and
if so see if building without editorial stuff works.

Regardre pour le tamoul. DSAL+Cologne. First start with just a word index, then
add scans, then other stuff. Need to have a grammar that describes how
transliteration works and that has some stuff on phonetics in case we can

ID pour les <lg> Amandine ? Must keep a copy of the XML of each <lg> in the db,
with the repo name, the commit num and the file name and the line no, so that
we can point back to an older version if the ref is lost.

must make ids unique across all elements, not just lgs

create table verses(
   name text not null,
   id text not null,
   repo text,
   commit text,
   name text,
   data xml,
   line integer,
   column integer,
   primary key(name, id),
   foreign key(repo, name) references ...
);

Ajouter 2nd champ dans rech. parallèles; pour substring; allow custom threshold
for similarity? or make it automatic if we have no match? in fact should use a
heap and use a thresh > 0. also remove the "illegal input" thing. for the heap
use sqlite, for simplicity, add a function jaccard() and deal with that, and
paginate results. allow quoting part of the input to force an exact match.

<choice><unclear><unclear>..</choice> à garder dans les 2 affichages.
logical ajouter nums. de page.
ajouter avec js pas css

---

For searching and highlighting, maybe the most convenient option for now would
be to have an offset map for each search representation that maps each
character to the corresponding offset in the formatted representation. This can
be compressed with delta encoding and varints. Go for that instead of what is
said above. And search representations should be derived from the formatted
representation, and this should be done in go, with a separate process.
